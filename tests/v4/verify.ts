import { PasetoKeyInvalid, PasetoPayloadInvalid, PasetoSignatureInvalid, PasetoTokenInvalid } from '../../src/lib/errors';
import { stringToUint8Array, uint8ArrayToString } from '../../src/lib/uint8array';

import { base64UrlDecode } from '../../src/lib/base64url';
import { generateKeys } from '../../src/v4/key';
import { sign } from '../../src/v4/sign';
import { test, type TestContext } from 'node:test';
import { verify } from '../../src/v4/verify';

const keys = {
    secretKey: "k4.secret.FgbULh0ylLoBsG6KRi2ZM0ZDzNMgaCBp1jB0sbf8OXE",
    publicKey: "k4.public.gX_9QndMMg2u-p_ojdKho9L2mEruUF3WYW4-ZVFoZMg",
}
const PANVA_MESSAGE = JSON.stringify({
    sub: 'napoleon',
    iat: '2023-01-13T14:36:14.754Z',
    exp: '3023-01-09T15:34:46.865Z'
});
const PANVA_TOKEN = 'v4.public.eyJzdWIiOiJuYXBvbGVvbiIsImlhdCI6IjIwMjMtMDEtMTNUMTQ6MzY6MTQuNzU0WiIsImV4cCI6IjMwMjMtMDEtMDlUMTU6MzQ6NDYuODY1WiJ9DwetzN2O8ReSqW1MjRl__QOjIMPg2fTc6HnWdbDHbO74bj4idH20nxfvUG3NTI0k5iMNcWwYAf6dIl3yZ2PJBA';

test('it verifies a PASETO v4.public token generated using the supplied Ed25519 keys', async (t: TestContext) => {
    const token = await sign(keys.secretKey, PANVA_MESSAGE);
    const result = verify(keys.publicKey, token);
    t.assert.strictEqual(result.payload.sub, 'napoleon');
});

test('it verifies a PASETO v4.public token generated by panva/paseto', async (t: TestContext) => {
    const result = verify(keys.publicKey, PANVA_TOKEN);
    t.assert.strictEqual(result.payload.sub, 'napoleon');
});

test('it verifies a PASETO v4.public token generated by panva/paseto (uint8array input)', async (t: TestContext) => {
    const result = verify(keys.publicKey, stringToUint8Array(PANVA_TOKEN));
    t.assert.strictEqual(result.payload.sub, 'napoleon');
});

test('it throws if the token is invalid', async (t: TestContext) => {
    try {
        const result = verify(keys.publicKey, 'a' + PANVA_TOKEN);
        t.assert.fail('should have thrown');
    } catch (err) {
        t.assert.strictEqual(err instanceof PasetoTokenInvalid, true);
    }
});

test('it throws if the token is invalid', async (t: TestContext) => {
    try {
        const result = verify<{ foo: string }>(keys.publicKey, PANVA_TOKEN+'a');
        t.assert.fail('should have thrown');
    } catch (err) {
        t.assert.strictEqual(err instanceof PasetoSignatureInvalid, true);
    }
});

test('it throws if the token is invalid (uint8array)', async (t: TestContext) => {
    try {
        const result = verify(keys.publicKey, stringToUint8Array('a' + PANVA_TOKEN));
        t.assert.fail('should have thrown');
    } catch (err) {
        t.assert.strictEqual(err instanceof PasetoTokenInvalid, true);
    }
});

test('it throws if the token is not a string or uint8array', async (t: TestContext) => {
    try {
        const result = verify(keys.publicKey, 1 as any);
        t.assert.fail('should have thrown');
    } catch (err) {
        t.assert.strictEqual(err instanceof PasetoTokenInvalid, true);
    }
});

test('it verifies a token with a footer', async (t: TestContext) => {
    const token = await sign(keys.secretKey, PANVA_MESSAGE, {
        footer: 'test',
    });
    const result = verify(keys.publicKey, token);
    t.assert.strictEqual(result.payload.sub, 'napoleon');
    t.assert.strictEqual(result.footer, 'test');
});

test('it throws if token has more than 4 parts', async (t: TestContext) => {
    try {
        const result = verify(keys.publicKey, PANVA_TOKEN + '.a.b.c');
        t.assert.fail('should have thrown');
    } catch (err) {
        t.assert.strictEqual(err instanceof PasetoTokenInvalid, true);
    }
});

test('it throws if payload is less than 64 bytes', async (t: TestContext) => {
    try {
        const result = verify(keys.publicKey, 'v4.public.abc');
        t.assert.fail('should have thrown');
    } catch (err) {
        t.assert.strictEqual(err instanceof PasetoTokenInvalid, true);
    }
});

test('it uses an assertion if provided', async (t: TestContext) => {
    const token = await sign(keys.secretKey, PANVA_MESSAGE, {
        footer: 'test',
        assertion: 'abc'
    });
    const result = verify(keys.publicKey, token, {
        assertion: 'abc'
    });
    t.assert.strictEqual(result.payload.sub, 'napoleon');
    t.assert.strictEqual(result.footer, 'test');
});

test('it fails if assertion is incorrect', async (t: TestContext) => {
    const token = await sign(keys.secretKey, PANVA_MESSAGE, {
        footer: 'test',
        assertion: 'abc'
    });
    try {
        const result = verify(keys.publicKey, token, {
            assertion: 'abcd'
        });
        t.assert.fail('should have thrown');
    } catch (err) {
        t.assert.strictEqual(err instanceof PasetoSignatureInvalid, true);
    }
});
